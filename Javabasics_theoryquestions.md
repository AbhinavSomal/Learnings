📚 🗓️ Week 1: Java Basics + Arrays
✅ Java Basics – Theory Questions
Explain the differences between int[] arr = new int[5]; and int[] arr = {1, 2, 3, 4, 5};. When would you use each?

What are the different types of loops in Java? Describe with syntax and flow control.

What are primitive vs non-primitive data types in Java? Give 3 examples of each.

How does memory allocation for arrays in Java work? Explain stack vs heap with respect to arrays.

What is the difference between pass-by-value and pass-by-reference in Java? How does Java handle method parameters?

✅ Arrays & Control Flow – Theory Questions
Explain the concept of time complexity using an example of linear vs binary search.

What are the edge cases to consider when working with arrays (e.g., empty array, out of bounds, null)?

How does array rotation work? How is it different from array reversal? Explain with an example.

Describe the differences between break, continue, and return in loops and methods.

What is the significance of array sorting before applying the two-pointer technique?

📚 🗓️ Week 2: Strings + Recursion
✅ Strings & StringBuilder – Theory Questions
What are immutable objects in Java? Why is String immutable while StringBuilder is mutable?

Compare performance and thread-safety of String, StringBuilder, and StringBuffer.

How does Java handle character encoding? What is Unicode and how does it impact string operations?

Explain the role of StringBuilder in reducing time complexity in repetitive concatenation scenarios.

Why is using + operator in a loop on strings inefficient? Illustrate with a time complexity example.

✅ Recursion, Subsequence, Palindrome, Backtracking – Theory Questions
Define recursion. What are its two essential parts? Explain with an example.

What is a stack overflow in recursion? How can it be prevented?

What is the difference between direct recursion and indirect recursion? Give examples.

Explain the concept of backtracking. How is it different from brute force?

Describe the time complexity of recursive approaches for subsequence generation and N-Queens. Why do these problems grow exponentially?
